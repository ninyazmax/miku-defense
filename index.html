<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miku Defense - Tower Defense</title>
    <style>
        :root {
            --primary-color: #6a5acd;
            --secondary-color: #9370db;
            --accent-color: #ff69b4;
            --text-color: #ffffff;
            --background-dark: #1a1a2e;
            --button-hover: #7b68ee;
            --health-color: #ff4444;
            --coin-color: #ffd700;
            --path-color: #8b4513;
            --grass-color: #2e8b57;
            /* Colores para el mapa de pixel art */
            --pixel-grass-dark: #2c5545;
            --pixel-grass-light: #4c8a66;
            --pixel-path-dark: #6b4c30;
            --pixel-path-light: #a37f5d;
        }
        /* Utiliza 'Press Start 2P' para un estilo retro */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
        }
        body {
            background-color: var(--background-dark);
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        /* Men√∫ Principal */
        .main-menu {
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('https://i.pinimg.com/originals/4c/23/98/4c2398e6be397bb08b5cb70b2192d730.gif') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .menu-title {
            font-size: clamp(2rem, 5vw, 3rem);
            margin-bottom: 2rem;
            text-shadow: 4px 4px 0px #000;
            color: var(--accent-color);
            animation: pulse 2s infinite;
        }
        .menu-button {
            background-color: var(--primary-color);
            color: white;
            border: 3px solid black;
            padding: 1rem 2rem;
            margin: 0.5rem;
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.5);
        }
        .menu-button:hover {
            background-color: var(--button-hover);
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px rgba(0, 0, 0, 0.5);
        }
        .menu-button:active {
            transform: translate(0, 0);
            box-shadow: 3px 3px 0px rgba(0, 0, 0, 0.5);
        }
        /* Nuevo: Pantalla de Lobby */
        .lobby-container {
            display: none;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('https://i.pinimg.com/originals/71/f1/b9/71f1b924a56150104ec16828f2d31b7f.gif') no-repeat center center;
            background-size: cover;
            z-index: 90;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }
        .lobby-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .room-info {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border: 3px solid var(--accent-color);
            text-shadow: 2px 2px 0px #000;
        }
        .room-code {
            font-size: clamp(1rem, 3vw, 2rem);
            margin-bottom: 0.5rem;
        }
        .player-count {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            color: #ccc;
        }
        .player-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 2rem;
        }
        .player-slot {
            width: 120px;
            height: 140px;
            background-color: rgba(0, 0, 0, 0.5);
            margin: 0.5rem;
            border: 2px dashed var(--text-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0.5rem;
        }
        .player-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            margin-bottom: 0.5rem;
            position: relative;
            overflow: hidden;
        }
        .player-avatar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
        }
        .player-name {
            font-size: clamp(0.6rem, 1.5vw, 0.8rem);
            word-break: break-word;
            color: var(--text-color);
            background: transparent;
            border: none;
            text-align: center;
            width: 100%;
            padding: 0.2rem;
            outline: none;
            transition: color 0.3s;
        }
        .player-name:focus {
            color: var(--accent-color);
        }
        .player-name::placeholder {
            color: #666;
        }
        /* Juego */
        .game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            justify-content: center;
            align-items: center;
        }
        .game-wrapper {
            display: flex;
            border: 5px solid black;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #000;
        }
        .game-map {
            width: 800px;
            height: 600px;
            background: #2e8b57; /* color base, pero se sobreescribe por el canvas */
            position: relative;
            overflow: hidden;
        }
        #gameCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .tower-spot {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
        }
        .tower {
            position: absolute;
            width: 32px;
            height: 32px;
            transform: translate(-50%, -50%);
            z-index: 10;
            cursor: pointer;
        }
        .enemy {
            position: absolute;
            width: 32px;
            height: 32px;
            z-index: 8;
            transform: translate(-50%, -50%);
        }
        .enemy-sprite {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            image-rendering: pixelated;
        }
        .projectile {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            z-index: 5;
        }
        /* UI */
        .game-ui {
            width: 200px;
            height: 600px;
            background-color: var(--background-dark);
            border-left: 3px solid var(--primary-color);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 1rem;
        }
        .ui-section {
            width: 100%;
            margin-bottom: 1.5rem;
        }
        .ui-section h3 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--accent-color);
            text-align: center;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            background: #333;
            padding: 0.5rem;
            border-radius: 5px;
            margin-bottom: 0.5rem;
        }
        .tower-select {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .tower-option {
            width: 70px;
            height: 70px;
            border: 2px solid black;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            font-size: 0.8rem;
            transition: transform 0.2s;
            background-color: rgba(255, 255, 255, 0.1);
        }
        .tower-option:hover {
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 0.2);
        }
        /* Estilos espec√≠ficos para las torres */
        .tower-option.miku { background-color: #39c5bb; }
        .tower-option.teto { background-color: #ff9ec6; }
        .tower-option.neru { background-color: #ffcc22; }
        .tower-cost {
            position: absolute;
            bottom: -18px;
            font-size: 0.6rem;
            color: var(--coin-color);
            text-shadow: 1px 1px 0px #000;
        }
        .upgrade-panel {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 1rem;
            border: 2px solid var(--primary-color);
            display: none;
            z-index: 20;
            box-shadow: 0 0 10px #000;
            border-radius: 5px;
        }
        .upgrade-panel h3 {
            color: var(--accent-color);
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .upgrade-option {
            background-color: #444;
            color: white;
            padding: 0.5rem 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            font-size: 0.7rem;
            text-align: center;
            transition: background 0.2s;
            border-radius: 3px;
        }
        .upgrade-option:hover {
            background-color: #666;
        }
        /* Animaciones */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .floating {
            animation: float 3s ease-in-out infinite;
        }
        /* Game Over Overlay */
        .game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        .game-over-message {
            font-size: 2.5rem;
            color: #ff4444;
            text-shadow: 4px 4px 0px #000;
            margin-bottom: 1rem;
            text-align: center;
        }
        .game-over-stats {
            font-size: 1.2rem;
            color: white;
            text-align: center;
            margin-bottom: 2rem;
        }
        .game-over-button {
            background-color: var(--primary-color);
            color: white;
            padding: 0.8rem 1.5rem;
            border: 2px solid black;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            transition: all 0.3s;
            box-shadow: 3px 3px 0px rgba(0, 0, 0, 0.5);
        }
        .game-over-button:hover {
            background-color: var(--button-hover);
            transform: translate(-2px, -2px);
            box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <!-- Men√∫ Principal -->
    <div class="main-menu" id="mainMenu">
        <h1 class="menu-title floating">Miku Defense</h1>
        <button class="menu-button" id="createRoomBtn">Crear Sala</button>
        <button class="menu-button" id="joinRoomBtn">Unirse a Sala</button>
        <button class="menu-button" id="profileBtn">Mi Perfil</button>
        <button class="menu-button" id="shopBtn">Tienda</button>
        <button class="menu-button" id="creditsBtn">Cr√©ditos</button>
    </div>
    <!-- Lobby -->
    <div class="lobby-container" id="lobbyContainer">
        <div class="lobby-header">
            <div class="room-info">
                <div class="room-code" id="roomCodeDisplay">C√≥digo: ABCD12</div>
                <div class="player-count" id="playerCountDisplay">Jugadores: 1/3</div>
            </div>
        </div>
        <div class="player-list">
            <div class="player-slot">
                <div class="player-avatar"></div>
                <input class="player-name" id="player1Name" maxlength="12" value="T√∫"/>
            </div>
            <div class="player-slot">
                <div class="player-avatar"></div>
                <input class="player-name" id="player2Name" maxlength="12" value="Esperando..."/>
            </div>
            <div class="player-slot">
                <div class="player-avatar"></div>
                <input class="player-name" id="player3Name" maxlength="12" value="Esperando..."/>
            </div>
        </div>
        <button class="menu-button" id="startGameBtn">Iniciar Juego</button>
        <button class="menu-button" id="leaveLobbyBtn">Salir del Lobby</button>
    </div>
    <!-- Juego -->
    <div class="game-container" id="gameContainer">
        <div class="game-wrapper">
            <!-- Nuevo: Canvas para el mapa de pixel art -->
            <div class="game-map" id="gameMap">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="game-ui">
                <div class="ui-section">
                    <h3>Estado</h3>
                    <div class="status-bar">
                        <span>‚ù§Ô∏è Vida:</span>
                        <span id="healthCount">100</span>
                    </div>
                    <div class="status-bar">
                        <span>ü™ô Monedas:</span>
                        <span id="coinCount">500</span>
                    </div>
                    <div class="status-bar">
                        <span>Ronda:</span>
                        <span id="waveCount">0/20</span>
                    </div>
                </div>
                <div class="ui-section">
                    <h3>Torres</h3>
                    <div class="tower-select">
                        <div class="tower-option miku" data-tower="miku">
                            Miku
                            <div class="tower-cost">$100</div>
                        </div>
                        <div class="tower-option teto" data-tower="teto">
                            Teto
                            <div class="tower-cost">$150</div>
                        </div>
                        <div class="tower-option neru" data-tower="neru">
                            Neru
                            <div class="tower-cost">$200</div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Panel de mejoras (oculto por defecto) -->
            <div class="upgrade-panel" id="upgradePanel">
                <h3>Mejoras</h3>
                <div class="upgrade-option" data-upgrade="damage">Da√±o (+10%) - $100</div>
                <div class="upgrade-option" data-upgrade="speed">Velocidad (+10%) - $100</div>
                <div class="upgrade-option" data-upgrade="range">Rango (+10%) - $100</div>
                <div class="upgrade-option" data-upgrade="special">Ataque Especial - $300</div>
            </div>
        </div>
    </div>
    <!-- Game Over Overlay -->
    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-message">¬°Game Over!</div>
        <div class="game-over-stats" id="gameOverStats">Llegaste a la oleada 0</div>
        <button class="game-over-button" id="restartGameBtn">Volver al Men√∫</button>
    </div>
    <!-- Modales para Perfil y Cr√©ditos -->
    <div class="modal" id="profileModal">
        <div class="modal-content">
            <h2>Mi Perfil</h2>
            <input type="text" id="playerNameInput" placeholder="Tu nombre" maxlength="12">
            <button id="saveProfileBtn">Guardar</button>
        </div>
    </div>
    <div class="modal" id="creditsModal">
        <div class="modal-content">
            <h2>Cr√©ditos</h2>
            <p><strong>Desarrollado por:</strong> [Tu Nombre]</p>
            <p><strong>Arte y Dise√±o:</strong> [Colaborador 1]</p>
            <p><strong>M√∫sica:</strong> [Colaborador 2]</p>
            <button id="closeCreditsBtn">Cerrar</button>
        </div>
    </div>
    <script>
        // Variables del juego
        let gameState = 'menu'; // menu, lobby, game
        let selectedTower = null;
        let coins = 500;
        let health = 100;
        let currentWave = 0;
        let enemies = [];
        let towers = [];
        let projectiles = [];
        let playerName = "Jugador";
        let roomCode = "";
        let players = [];
        let gameRunning = false;
        let gameOverState = false;
        // Elementos del DOM
        const mainMenu = document.getElementById('mainMenu');
        const lobbyContainer = document.getElementById('lobbyContainer');
        const gameContainer = document.getElementById('gameContainer');
        const gameMap = document.getElementById('gameMap');
        const healthCount = document.getElementById('healthCount');
        const coinCount = document.getElementById('coinCount');
        const waveCount = document.getElementById('waveCount');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const playerCountDisplay = document.getElementById('playerCountDisplay');
        const player1Name = document.getElementById('player1Name');
        const player2Name = document.getElementById('player2Name');
        const player3Name = document.getElementById('player3Name');
        const upgradePanel = document.getElementById('upgradePanel');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverStats = document.getElementById('gameOverStats');
        const restartGameBtn = document.getElementById('restartGameBtn');
        // Configuraci√≥n del juego
        const PIXEL_SIZE = 8; // Tama√±o de cada "p√≠xel" del mapa
        const MAP_WIDTH = 800;
        const MAP_HEIGHT = 600;
        const MAX_WAVES = 20;
        gameCanvas.width = MAP_WIDTH;
        gameCanvas.height = MAP_HEIGHT;
        gameMap.style.width = `${MAP_WIDTH}px`;
        gameMap.style.height = `${MAP_HEIGHT}px`;
        
        // NUEVO: Coordenadas del camino para el mapa de pixel art con mejor flujo
        const path = [
            { x: 100, y: 500 },  // Start bottom left
            { x: 100, y: 300 },  // Up
            { x: 300, y: 300 },  // Right
            { x: 300, y: 150 },  // Up
            { x: 500, y: 150 },  // Right
            { x: 500, y: 350 },  // Down
            { x: 700, y: 350 }   // Right to end
        ];
        
        // Enemigos con sprites detallados de 32x32
        const enemySprites = {
            // Slime - Enemigo b√°sico
            slime: {
                draw: function(ctx, x, y) {
                    // Cuerpo principal
                    ctx.fillStyle = '#39c5bb';
                    ctx.fillRect(x + 8, y + 16, 16, 16);
                    
                    // Efecto de gelatina
                    ctx.fillStyle = '#a0e8e8';
                    ctx.fillRect(x + 10, y + 18, 12, 12);
                    
                    // Ojos
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x + 12, y + 18, 4, 4);
                    ctx.fillRect(x + 18, y + 18, 4, 4);
                    
                    // Pupilas
                    ctx.fillStyle = 'black';
                    ctx.fillRect(x + 14, y + 20, 1, 1);
                    ctx.fillRect(x + 20, y + 20, 1, 1);
                    
                    // Bordes negros para resaltar el pixel art
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 8, y + 16, 16, 16);
                    ctx.strokeRect(x + 12, y + 18, 4, 4);
                    ctx.strokeRect(x + 18, y + 18, 4, 4);
                }
            },
            // Goblin - Enemigo mediano
            goblin: {
                draw: function(ctx, x, y) {
                    // Cuerpo
                    ctx.fillStyle = '#ff9ec6';
                    ctx.fillRect(x + 8, y + 14, 16, 16);
                    
                    // Cabeza
                    ctx.fillRect(x + 10, y + 8, 12, 8);
                    
                    // Orejas puntiagudas
                    ctx.fillRect(x + 8, y + 10, 2, 4);
                    ctx.fillRect(x + 22, y + 10, 2, 4);
                    
                    // Ojos rojos
                    ctx.fillStyle = 'red';
                    ctx.fillRect(x + 12, y + 11, 2, 2);
                    ctx.fillRect(x + 18, y + 11, 2, 2);
                    
                    // Boca con dientes
                    ctx.fillStyle = 'black';
                    ctx.fillRect(x + 15, y + 15, 2, 1);
                    
                    // Brazos
                    ctx.fillRect(x + 6, y + 16, 2, 6);
                    ctx.fillRect(x + 24, y + 16, 2, 6);
                    
                    // Piernas
                    ctx.fillRect(x + 10, y + 30, 4, 2);
                    ctx.fillRect(x + 18, y + 30, 4, 2);
                    
                    // Bordes negros
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 8, y + 14, 16, 16);
                    ctx.strokeRect(x + 10, y + 8, 12, 8);
                    ctx.strokeRect(x + 8, y + 10, 2, 4);
                    ctx.strokeRect(x + 22, y + 10, 2, 4);
                    ctx.strokeRect(x + 6, y + 16, 2, 6);
                    ctx.strokeRect(x + 24, y + 16, 2, 6);
                }
            },
            // Orc - Enemigo fuerte
            orc: {
                draw: function(ctx, x, y) {
                    // Cuerpo musculoso
                    ctx.fillStyle = '#ffcc22';
                    ctx.fillRect(x + 8, y + 12, 16, 18);
                    
                    // Cabeza grande
                    ctx.fillRect(x + 10, y + 6, 12, 8);
                    
                    // Nariz grande
                    ctx.fillStyle = '#e0b400';
                    ctx.fillRect(x + 15, y + 10, 2, 2);
                    
                    // Ojos peque√±os
                    ctx.fillStyle = 'black';
                    ctx.fillRect(x + 12, y + 9, 2, 2);
                    ctx.fillRect(x + 18, y + 9, 2, 2);
                    
                    // Boca abierta
                    ctx.fillRect(x + 15, y + 13, 2, 1);
                    
                    // Brazos fuertes
                    ctx.fillRect(x + 6, y + 14, 2, 8);
                    ctx.fillRect(x + 24, y + 14, 2, 8);
                    
                    // Piernas gruesas
                    ctx.fillRect(x + 10, y + 30, 4, 4);
                    ctx.fillRect(x + 18, y + 30, 4, 4);
                    
                    // Maza
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x + 4, y + 10, 2, 10);
                    ctx.fillRect(x + 3, y + 8, 4, 3);
                    
                    // Bordes negros
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 8, y + 12, 16, 18);
                    ctx.strokeRect(x + 10, y + 6, 12, 8);
                    ctx.strokeRect(x + 6, y + 14, 2, 8);
                    ctx.strokeRect(x + 24, y + 14, 2, 8);
                    ctx.strokeRect(x + 4, y + 10, 2, 10);
                    ctx.strokeRect(x + 3, y + 8, 4, 3);
                }
            },
            // Skeleton - Enemigo esquel√©tico
            skeleton: {
                draw: function(ctx, x, y) {
                    // Cabeza (calavera)
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x + 12, y + 8, 8, 8);
                    
                    // Ojos vac√≠os
                    ctx.fillStyle = 'black';
                    ctx.fillRect(x + 14, y + 10, 2, 2);
                    ctx.fillRect(x + 18, y + 10, 2, 2);
                    
                    // Columna vertebral
                    ctx.fillRect(x + 16, y + 16, 2, 10);
                    
                    // Costillas
                    ctx.fillRect(x + 14, y + 18, 2, 2);
                    ctx.fillRect(x + 18, y + 18, 2, 2);
                    ctx.fillRect(x + 14, y + 22, 2, 2);
                    ctx.fillRect(x + 18, y + 22, 2, 2);
                    
                    // Brazos
                    ctx.fillRect(x + 10, y + 16, 2, 6);
                    ctx.fillRect(x + 20, y + 16, 2, 6);
                    
                    // Piernas
                    ctx.fillRect(x + 14, y + 28, 2, 4);
                    ctx.fillRect(x + 18, y + 28, 2, 4);
                    
                    // Bordes negros
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 12, y + 8, 8, 8);
                    ctx.strokeRect(x + 16, y + 16, 2, 10);
                    ctx.strokeRect(x + 14, y + 18, 2, 2);
                    ctx.strokeRect(x + 18, y + 18, 2, 2);
                    ctx.strokeRect(x + 14, y + 22, 2, 2);
                    ctx.strokeRect(x + 18, y + 22, 2, 2);
                }
            },
            // Dragon - Jefe final
            dragon: {
                draw: function(ctx, x, y) {
                    // Cabeza del drag√≥n
                    ctx.fillStyle = '#800080';
                    ctx.fillRect(x + 8, y + 8, 16, 12);
                    
                    // Ojos rojos
                    ctx.fillStyle = 'red';
                    ctx.fillRect(x + 12, y + 10, 2, 2);
                    ctx.fillRect(x + 18, y + 10, 2, 2);
                    
                    // Cuernos
                    ctx.fillStyle = '#663300';
                    ctx.fillRect(x + 8, y + 8, 2, 4);
                    ctx.fillRect(x + 22, y + 8, 2, 4);
                    
                    // Cuerpo escamoso
                    ctx.fillStyle = '#993399';
                    ctx.fillRect(x + 10, y + 20, 12, 8);
                    
                    // Alas
                    ctx.fillStyle = '#440044';
                    ctx.fillRect(x + 6, y + 16, 4, 8);
                    ctx.fillRect(x + 22, y + 16, 4, 8);
                    
                    // Cola
                    ctx.fillRect(x + 16, y + 28, 2, 4);
                    ctx.fillRect(x + 18, y + 30, 2, 2);
                    
                    // Bordes negros
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 8, y + 8, 16, 12);
                    ctx.strokeRect(x + 10, y + 20, 12, 8);
                    ctx.strokeRect(x + 6, y + 16, 4, 8);
                    ctx.strokeRect(x + 22, y + 16, 4, 8);
                }
            }
        };

        // Inicializaci√≥n del juego
        window.onload = function() {
            init();
        }
        
        function init() {
            // Event listeners para los botones del men√∫
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('joinRoomBtn').addEventListener('click', joinRoom);
            document.getElementById('profileBtn').addEventListener('click', showProfile);
            document.getElementById('shopBtn').addEventListener('click', () => alert("Tienda - En desarrollo"));
            document.getElementById('creditsBtn').addEventListener('click', showCredits);
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('leaveLobbyBtn').addEventListener('click', leaveLobby);
            document.getElementById('saveProfileBtn').addEventListener('click', saveProfile);
            document.getElementById('closeCreditsBtn').addEventListener('click', closeCredits);
            document.getElementById('restartGameBtn').addEventListener('click', restartGame);
            
            // Configurar torres seleccionables
            document.querySelectorAll('.tower-option').forEach(option => {
                option.addEventListener('click', function() {
                    selectedTower = this.getAttribute('data-tower');
                });
            });
            
            // Configurar clic en el mapa para torres
            gameMap.addEventListener('click', function(e) {
                if (selectedTower && gameRunning && !gameOverState) {
                    const rect = gameCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    placeTowerAt(x, y);
                }
            });
        }
        
        // NUEVO: Mapa de pixel art bosque detallado con bordes negros finos
        function drawMap() {
            ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
            
            // Fondo de pasto moteado con patr√≥n de cuadr√≠cula pixelado
            for (let y = 0; y < MAP_HEIGHT; y += 8) {
                for (let x = 0; x < MAP_WIDTH; x += 8) {
                    // Alternar colores para crear patr√≥n
                    let color;
                    if ((x / 8 + y / 8) % 2 === 0) {
                        color = "#2c5545"; // Verde oscuro
                    } else {
                        color = "#4c8a66"; // Verde claro
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 8, 8);
                    
                    // A√±adir detalle de textura
                    ctx.fillStyle = "#3a7358";
                    ctx.fillRect(x + 2, y + 2, 2, 2);
                    ctx.fillRect(x + 5, y + 5, 2, 2);
                }
            }
            
            // Camino de piedra con bordes negros definidos
            ctx.lineWidth = 32;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Sombra del camino
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.strokeStyle = '#000'; // Borde negro exterior
            ctx.stroke();
            
            // Camino principal (m√°s delgado)
            ctx.lineWidth = 24;
            ctx.shadowColor = 'transparent';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            
            // Degradado de piedra para el camino
            let grad = ctx.createLinearGradient(0, 0, MAP_WIDTH, MAP_HEIGHT);
            grad.addColorStop(0, "#a37f5d");
            grad.addColorStop(0.5, "#c8a58c");
            grad.addColorStop(1, "#a37f5d");
            ctx.strokeStyle = grad;
            ctx.stroke();
            
            // Borde interno del camino
            ctx.lineWidth = 16;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.strokeStyle = "#6b4c30";
            ctx.stroke();
            
            // Restaurar estado del contexto
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Detalles del mapa
            drawForestDetails();
        }
        
        function drawForestDetails() {
            // √Årboles grandes
            drawTree(120, 80, 32, "#22613b", "#6b4c30");
            drawTree(320, 60, 32, "#22613b", "#6b4c30");
            drawTree(700, 80, 32, "#22613b", "#6b4c30");
            drawTree(600, 180, 32, "#22613b", "#6b4c30");
            drawTree(200, 500, 32, "#22613b", "#6b4c30");
            drawTree(500, 500, 32, "#22613b", "#6b4c30");
            drawTree(700, 400, 32, "#22613b", "#6b4c30");
            
            // √Årboles peque√±os
            drawTree(250, 200, 24, "#3d6e4a", "#8b5e3c");
            drawTree(400, 300, 24, "#3d6e4a", "#8b5e3c");
            drawTree(600, 80, 24, "#3d6e4a", "#8b5e3c");
            drawTree(150, 350, 24, "#3d6e4a", "#8b5e3c");
            drawTree(350, 400, 24, "#3d6e4a", "#8b5e3c");
            
            // Rocas
            drawRock(650, 200);
            drawRock(300, 350);
            drawRock(100, 200);
            drawRock(450, 100);
            
            // Flores
            drawFlower(720, 150, "#a23ecb");
            drawFlower(600, 420, "#e04e8a");
            drawFlower(200, 100, "#fff");
            drawFlower(500, 250, "#f7e36a");
            
            // Setas
            drawMushroom(220, 180);
            drawMushroom(320, 520);
            drawMushroom(650, 320);
            drawMushroom(180, 400);
            
            // Cueva
            drawCave(100, 540);
            
            // Arbustos
            drawBush(400, 500);
            drawBush(700, 500);
            drawBush(150, 150);
        }
        
        function drawTree(x, y, size, leafColor, trunkColor) {
            // Tronco
            ctx.fillStyle = trunkColor;
            ctx.fillRect(x + size/2 - 4, y + size - 8, 8, 16);
            
            // Copa del √°rbol
            ctx.fillStyle = leafColor;
            ctx.fillRect(x + size/2 - 12, y, 24, size - 8);
            ctx.fillRect(x + size/2 - 8, y - 8, 16, 8);
            
            // Detalles de la copa
            ctx.fillStyle = "#1a482a";
            ctx.fillRect(x + size/2 - 10, y + 2, 20, size - 10);
            ctx.fillRect(x + size/2 - 6, y - 6, 12, 6);
            
            // Bordes negros
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(x + size/2 - 12, y, 24, size - 8);
            ctx.strokeRect(x + size/2 - 8, y - 8, 16, 8);
            ctx.strokeRect(x + size/2 - 4, y + size - 8, 8, 16);
        }
        
        function drawRock(x, y) {
            // Roca grande
            ctx.fillStyle = "#888";
            ctx.fillRect(x, y, 24, 16);
            ctx.fillRect(x + 4, y - 4, 16, 8);
            ctx.fillRect(x + 8, y - 8, 8, 4);
            
            // Sombra
            ctx.fillStyle = "#555";
            ctx.fillRect(x + 16, y + 4, 4, 8);
            ctx.fillRect(x + 12, y, 4, 4);
            
            // Bordes
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, 24, 16);
            ctx.strokeRect(x + 4, y - 4, 16, 8);
            ctx.strokeRect(x + 8, y - 8, 8, 4);
        }
        
        function drawFlower(x, y, color) {
            // Tallo
            ctx.fillStyle = "#228B22";
            ctx.fillRect(x + 4, y + 8, 4, 16);
            
            // P√©talos
            ctx.fillStyle = color;
            ctx.fillRect(x, y, 12, 8);
            ctx.fillRect(x + 2, y - 4, 8, 8);
            
            // Centro
            ctx.fillStyle = "#FFD700";
            ctx.fillRect(x + 4, y + 2, 4, 4);
            
            // Bordes
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 4, y + 8, 4, 16);
            ctx.strokeRect(x, y, 12, 8);
            ctx.strokeRect(x + 2, y - 4, 8, 8);
            ctx.strokeRect(x + 4, y + 2, 4, 4);
        }
        
        function drawMushroom(x, y) {
            // Sombrero
            ctx.fillStyle = "#FF6347";
            ctx.fillRect(x + 2, y, 20, 8);
            ctx.fillRect(x, y + 2, 24, 6);
            ctx.fillRect(x + 4, y + 4, 16, 4);
            
            // Pie
            ctx.fillStyle = "#FFF";
            ctx.fillRect(x + 8, y + 8, 8, 12);
            
            // Detalles
            ctx.fillStyle = "#FF4500";
            ctx.fillRect(x + 6, y + 2, 4, 2);
            ctx.fillRect(x + 14, y + 4, 4, 2);
            ctx.fillRect(x + 10, y + 6, 4, 2);
            
            // Bordes
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 2, y, 20, 8);
            ctx.strokeRect(x, y + 2, 24, 6);
            ctx.strokeRect(x + 4, y + 4, 16, 4);
            ctx.strokeRect(x + 8, y + 8, 8, 12);
        }
        
        function drawCave(x, y) {
            // Entrada de cueva
            ctx.fillStyle = "#555";
            ctx.beginPath();
            ctx.arc(x + 12, y, 12, 0, Math.PI, false);
            ctx.fill();
            
            // Interior oscuro
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(x + 12, y + 2, 8, 0, Math.PI, false);
            ctx.fill();
            
            // Antorcha
            ctx.fillStyle = "#FFA500";
            ctx.fillRect(x + 6, y - 12, 4, 6);
            ctx.fillStyle = "#FF4500";
            ctx.fillRect(x + 4, y - 16, 8, 6);
            
            // Bordes
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 12, y, 12, 0, Math.PI, false);
            ctx.stroke();
            ctx.strokeRect(x + 6, y - 12, 4, 6);
        }
        
        function drawBush(x, y) {
            // Arbusto
            ctx.fillStyle = "#228B22";
            ctx.fillRect(x, y, 24, 16);
            ctx.fillRect(x + 4, y - 4, 16, 8);
            ctx.fillRect(x + 8, y - 8, 8, 4);
            
            // Detalles
            ctx.fillStyle = "#006400";
            ctx.fillRect(x + 4, y + 2, 16, 12);
            ctx.fillRect(x + 8, y - 2, 8, 6);
            
            // Bordes
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, 24, 16);
            ctx.strokeRect(x + 4, y - 4, 16, 8);
            ctx.strokeRect(x + 8, y - 8, 8, 4);
        }
        
        // L√≥gica para colocar torres
        function placeTowerAt(x, y) {
            if (gameOverState) return;
            
            const cost = getTowerCost(selectedTower);
            if (coins < cost) {
                showMessage("Monedas insuficientes.");
                return;
            }
            
            // Evitar colocar torres en el camino
            if (isPointOnPath(x, y, 40)) {
                showMessage("No puedes construir en el camino.");
                return;
            }
            
            coins -= cost;
            updateCoinDisplay();
            const tower = document.createElement('div');
            tower.className = `tower ${selectedTower}`;
            tower.style.left = `${x}px`;
            tower.style.top = `${y}px`;
            tower.setAttribute('data-type', selectedTower);
            tower.addEventListener('click', showUpgrades);
            gameMap.appendChild(tower);
            
            // A√±adir a la l√≥gica del juego
            towers.push({
                element: tower,
                type: selectedTower,
                x: x,
                y: y,
                damage: 10,
                range: 100,
                cooldown: 1000,
                lastShot: 0,
                level: 1
            });
            
            selectedTower = null;
        }
        
        // Funci√≥n para verificar si un punto est√° cerca del camino
        function isPointOnPath(x, y, tolerance) {
            for (let i = 0; i < path.length - 1; i++) {
                const start = path[i];
                const end = path[i+1];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) continue;
                
                const t = Math.max(0, Math.min(1, ((x - start.x) * dx + (y - start.y) * dy) / (len * len)));
                const closestX = start.x + t * dx;
                const closestY = start.y + t * dy;
                const dist = Math.sqrt(Math.pow(x - closestX, 2) + Math.pow(y - closestY, 2));
                
                if (dist <= tolerance) return true;
            }
            return false;
        }
        
        function getTowerCost(type) {
            switch(type) {
                case 'miku': return 100;
                case 'teto': return 150;
                case 'neru': return 200;
                default: return 0;
            }
        }
        
        // Mostrar panel de mejoras
        function showUpgrades(e) {
            if (gameOverState) return;
            
            e.stopPropagation();
            const rect = gameContainer.getBoundingClientRect();
            upgradePanel.style.display = 'block';
            upgradePanel.style.left = `${e.clientX - rect.left}px`;
            upgradePanel.style.top = `${e.clientY - rect.top - upgradePanel.clientHeight - 10}px`;
            
            // Encontrar la torre en el array
            const towerElement = e.target;
            const towerIndex = towers.findIndex(t => t.element === towerElement);
            
            document.querySelectorAll('.upgrade-option').forEach(option => {
                option.onclick = function() {
                    upgradeTower(towerIndex, this.getAttribute('data-upgrade'));
                    upgradePanel.style.display = 'none';
                };
            });
        }
        
        // Mejorar torre
        function upgradeTower(index, upgradeType) {
            if (index < 0 || index >= towers.length || gameOverState) return;
            
            const tower = towers[index];
            const cost = upgradeType === 'special' ? 300 : 100;
            
            if (coins < cost) {
                showMessage("Monedas insuficientes para mejorar.");
                return;
            }
            
            coins -= cost;
            updateCoinDisplay();
            
            switch(upgradeType) {
                case 'damage': 
                    tower.damage = Math.floor(tower.damage * 1.1);
                    break;
                case 'speed': 
                    tower.cooldown = Math.floor(tower.cooldown * 0.9);
                    break;
                case 'range': 
                    tower.range = Math.floor(tower.range * 1.1);
                    break;
                case 'special': 
                    tower.special = 'active';
                    showMessage("¬°Ataque especial activado!");
                    break;
            }
            
            tower.level++;
        }
        
        // L√≥gica de oleadas de enemigos
        function startWave() {
            if (currentWave >= MAX_WAVES) {
                showMessage("¬°Has ganado el juego!");
                return;
            }
            
            currentWave++;
            waveCount.textContent = `${currentWave}/${MAX_WAVES}`;
            const enemyCount = 5 + currentWave * 2;
            
            // Determinar tipo de enemigo basado en la oleada
            let enemyType = 'slime';
            if (currentWave > 15) enemyType = 'dragon';
            else if (currentWave > 10) enemyType = 'skeleton';
            else if (currentWave > 5) enemyType = 'orc';
            else if (currentWave > 3) enemyType = 'goblin';
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    spawnEnemy(enemyType);
                }, i * 800);
            }
            
            // Preparar la siguiente ronda
            if (currentWave < MAX_WAVES) {
                setTimeout(() => {
                    if (enemies.length === 0 && !gameOverState) {
                        startWave();
                    }
                }, (enemyCount * 800) + 3000);
            }
        }
        
        function spawnEnemy(type = 'slime') {
            if (gameOverState) return;
            
            const enemyElement = document.createElement('div');
            enemyElement.className = 'enemy';
            enemyElement.style.width = '32px';
            enemyElement.style.height = '32px';
            enemyElement.style.left = `${path[0].x}px`;
            enemyElement.style.top = `${path[0].y}px`;
            
            // Crear canvas para el sprite del enemigo
            const spriteCanvas = document.createElement('canvas');
            spriteCanvas.width = 32;
            spriteCanvas.height = 32;
            spriteCanvas.className = 'enemy-sprite';
            const spriteCtx = spriteCanvas.getContext('2d');
            
            // Dibujar el sprite
            if (enemySprites[type]) {
                enemySprites[type].draw(spriteCtx, 0, 0);
            } else {
                // Sprite por defecto si no existe
                spriteCtx.fillStyle = '#39c5bb';
                spriteCtx.fillRect(8, 16, 16, 16);
                spriteCtx.fillStyle = 'white';
                spriteCtx.fillRect(12, 18, 4, 4);
                spriteCtx.fillRect(18, 18, 4, 4);
                spriteCtx.fillStyle = 'black';
                spriteCtx.fillRect(14, 20, 1, 1);
                spriteCtx.fillRect(20, 20, 1, 1);
            }
            enemyElement.appendChild(spriteCanvas);
            
            gameMap.appendChild(enemyElement);
            
            // Configurar propiedades seg√∫n el tipo
            let health, speed, reward;
            switch(type) {
                case 'slime':
                    health = 50 + currentWave * 5;
                    speed = 1 + currentWave * 0.1;
                    reward = 10 + currentWave * 1;
                    break;
                case 'goblin':
                    health = 75 + currentWave * 6;
                    speed = 1.2 + currentWave * 0.1;
                    reward = 15 + currentWave * 2;
                    break;
                case 'orc':
                    health = 100 + currentWave * 8;
                    speed = 0.8 + currentWave * 0.05;
                    reward = 20 + currentWave * 3;
                    break;
                case 'skeleton':
                    health = 150 + currentWave * 10;
                    speed = 1.5 + currentWave * 0.1;
                    reward = 30 + currentWave * 4;
                    break;
                case 'dragon':
                    health = 300 + currentWave * 15;
                    speed = 2.0 + currentWave * 0.1;
                    reward = 50 + currentWave * 5;
                    break;
                default:
                    health = 50 + currentWave * 5;
                    speed = 1 + currentWave * 0.1;
                    reward = 10 + currentWave * 1;
            }
            
            const enemyObj = {
                element: enemyElement,
                x: path[0].x,
                y: path[0].y,
                health: health,
                maxHealth: health,
                speed: speed,
                pathIndex: 0,
                reward: reward,
                type: type
            };
            
            enemies.push(enemyObj);
            // Iniciar movimiento
            moveEnemy(enemyObj);
        }
        
        function moveEnemy(enemy) {
            if (gameOverState) return;
            
            const nextPoint = path[enemy.pathIndex + 1];
            if (!nextPoint) {
                // El enemigo lleg√≥ al final
                takeDamage(10);
                removeEnemy(enemy);
                return;
            }
            
            const dx = nextPoint.x - enemy.x;
            const dy = nextPoint.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < enemy.speed) {
                // Lleg√≥ al siguiente punto del camino
                enemy.pathIndex++;
                moveEnemy(enemy);
            } else {
                // Mover hacia el siguiente punto
                enemy.x += (dx / distance) * enemy.speed;
                enemy.y += (dy / distance) * enemy.speed;
                enemy.element.style.left = `${enemy.x}px`;
                enemy.element.style.top = `${enemy.y}px`;
                requestAnimationFrame(() => moveEnemy(enemy));
            }
        }
        
        function takeDamage(amount) {
            if (gameOverState) return;
            
            health -= amount;
            healthCount.textContent = health;
            if (health <= 0) {
                gameOver();
            }
        }
        
        function removeEnemy(enemy) {
            const index = enemies.indexOf(enemy);
            if (index !== -1) {
                enemies.splice(index, 1);
                if (enemy.element && enemy.element.parentNode) {
                    gameMap.removeChild(enemy.element);
                }
                coins += enemy.reward;
                updateCoinDisplay();
            }
        }
        
        function updateCoinDisplay() {
            coinCount.textContent = coins;
        }
        
        // L√≥gica de disparo de torres
        function towerLogic(timestamp) {
            if (!gameRunning || gameOverState) return;
            
            towers.forEach(tower => {
                if (timestamp - tower.lastShot > tower.cooldown) {
                    const target = findTarget(tower);
                    if (target) {
                        shoot(tower, target);
                        tower.lastShot = timestamp;
                    }
                }
            });
            requestAnimationFrame(towerLogic);
        }
        
        function findTarget(tower) {
            // Encuentra el enemigo m√°s cercano que est√© dentro del rango
            let closestEnemy = null;
            let minDistance = tower.range;
            
            for (const enemy of enemies) {
                const dx = enemy.x - tower.x;
                const dy = enemy.y - tower.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= minDistance) {
                    minDistance = distance;
                    closestEnemy = enemy;
                }
            }
            return closestEnemy;
        }
        
        function shoot(tower, target) {
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            
            // Color del proyectil seg√∫n el tipo de torre
            if (tower.type === 'miku') projectile.style.backgroundColor = '#39c5bb';
            else if (tower.type === 'teto') projectile.style.backgroundColor = '#ff9ec6';
            else if (tower.type === 'neru') projectile.style.backgroundColor = '#ffcc22';
            
            projectile.style.left = `${tower.x}px`;
            projectile.style.top = `${tower.y}px`;
            gameMap.appendChild(projectile);
            
            const projectileObj = {
                element: projectile,
                x: tower.x,
                y: tower.y,
                target: target,
                damage: tower.damage,
                speed: 5,
                special: tower.special
            };
            
            projectiles.push(projectileObj);
        }
        
        function moveProjectiles() {
            if (!gameRunning || gameOverState) return;
            
            projectiles.forEach((proj, index) => {
                if (index >= projectiles.length) return;
                
                const target = proj.target;
                if (!target || !target.element || !target.element.parentNode) {
                    if (proj.element && proj.element.parentNode) {
                        gameMap.removeChild(proj.element);
                    }
                    projectiles.splice(index, 1);
                    return;
                }
                
                const dx = target.x - proj.x;
                const dy = target.y - proj.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < proj.speed) {
                    target.health -= proj.damage;
                    if (target.health <= 0) {
                        removeEnemy(target);
                    }
                    if (proj.element && proj.element.parentNode) {
                        gameMap.removeChild(proj.element);
                    }
                    projectiles.splice(index, 1);
                } else {
                    proj.x += (dx / distance) * proj.speed;
                    proj.y += (dy / distance) * proj.speed;
                    proj.element.style.left = `${proj.x}px`;
                    proj.element.style.top = `${proj.y}px`;
                }
            });
            
            requestAnimationFrame(moveProjectiles);
        }
        
        function gameOver() {
            if (gameOverState) return;
            
            gameOverState = true;
            gameRunning = false;
            
            // Mostrar overlay de Game Over
            gameOverStats.textContent = `Llegaste a la oleada ${currentWave}`;
            gameOverOverlay.style.display = 'flex';
            
            showMessage(`¬°Game Over! Llegaste a la oleada ${currentWave}`);
        }
        
        function restartGame() {
            gameOverOverlay.style.display = 'none';
            resetGame();
            showMainMenu();
        }
        
        function resetGame() {
            // Limpiar todos los elementos del juego
            enemies.forEach(e => { 
                if (e.element && e.element.parentNode) {
                    gameMap.removeChild(e.element);
                }
            });
            towers.forEach(t => { 
                if (t.element && t.element.parentNode) {
                    gameMap.removeChild(t.element);
                }
            });
            projectiles.forEach(p => { 
                if (p.element && p.element.parentNode) {
                    gameMap.removeChild(p.element);
                }
            });
            
            // Resetear variables
            enemies = [];
            towers = [];
            projectiles = [];
            coins = 500;
            health = 100;
            currentWave = 0;
            gameOverState = false;
            gameRunning = false;
            
            // Actualizar UI
            updateCoinDisplay();
            healthCount.textContent = health;
            waveCount.textContent = `0/${MAX_WAVES}`;
        }
        
        // Mensajes personalizados
        function showMessage(text) {
            const msgBox = document.createElement('div');
            msgBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 1rem 2rem;
                border: 2px solid var(--accent-color);
                z-index: 1000;
                font-family: 'Press Start 2P', cursive;
                text-align: center;
                animation: fade-in 0.5s forwards;
                border-radius: 5px;
            `;
            msgBox.textContent = text;
            document.body.appendChild(msgBox);
            
            setTimeout(() => {
                msgBox.style.animation = 'fade-out 0.5s forwards';
                setTimeout(() => {
                    if (msgBox.parentNode) {
                        document.body.removeChild(msgBox);
                    }
                }, 500);
            }, 2000);
        }
        
        // Funciones de red/multijugador (simuladas)
        function createRoom() {
            roomCode = generateRoomCode();
            players = [{ name: playerName }];
            updateLobbyUI();
            showLobby();
        }
        
        function joinRoom() {
            const code = prompt("Ingresa el c√≥digo de la sala:");
            if (code && code.length === 6) {
                roomCode = code;
                players = [
                    { name: "Anfitri√≥n" },
                    { name: playerName }
                ];
                updateLobbyUI();
                showLobby();
            }
        }
        
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        // NUEVO: Funci√≥n unificada para actualizar la UI del lobby
        function updateLobbyUI() {
            roomCodeDisplay.textContent = `C√≥digo: ${roomCode}`;
            playerCountDisplay.textContent = `Jugadores: ${players.length}/3`;
            
            // Inputs para nombres editables
            const playerInputs = [player1Name, player2Name, player3Name];
            playerInputs.forEach((el, i) => {
                if (players[i]) {
                    el.value = players[i].name;
                    el.disabled = (i !== 0); // Solo el primer jugador puede editar su nombre
                } else {
                    el.value = "Esperando...";
                    el.disabled = true;
                }
            });
        }
        
        // Permite editar el nombre del jugador local en el lobby
        player1Name.addEventListener('input', function() {
            if (players[0]) {
                players[0].name = player1Name.value.trim().substring(0, 12) || "T√∫";
            }
        });
        
        function startGame() {
            // Simular jugadores adicionales (para prueba)
            while (players.length < 3) {
                players.push({ name: "Jugador " + (players.length + 1) });
            }
            updateLobbyUI();
            showGame();
            
            // Iniciar l√≥gica del juego
            drawMap(); // Dibuja el mapa antes de iniciar
            gameRunning = true;
            gameOverState = false;
            
            setTimeout(() => startWave(), 3000);
            requestAnimationFrame(towerLogic);
            requestAnimationFrame(moveProjectiles);
        }
        
        // Funciones de navegaci√≥n
        function showMainMenu() {
            mainMenu.style.display = 'flex';
            lobbyContainer.style.display = 'none';
            gameContainer.style.display = 'none';
            gameOverOverlay.style.display = 'none';
            document.getElementById('profileModal').style.display = 'none';
            document.getElementById('creditsModal').style.display = 'none';
            gameState = 'menu';
        }
        
        function showLobby() {
            mainMenu.style.display = 'none';
            lobbyContainer.style.display = 'flex';
            gameContainer.style.display = 'none';
            gameOverOverlay.style.display = 'none';
            document.getElementById('profileModal').style.display = 'none';
            document.getElementById('creditsModal').style.display = 'none';
            gameState = 'lobby';
        }
        
        function showGame() {
            mainMenu.style.display = 'none';
            lobbyContainer.style.display = 'none';
            gameContainer.style.display = 'flex';
            gameOverOverlay.style.display = 'none';
            document.getElementById('profileModal').style.display = 'none';
            document.getElementById('creditsModal').style.display = 'none';
            gameState = 'game';
            
            // Redibuja el mapa con pixel art detallado
            drawMap();
        }
        
        function leaveLobby() {
            roomCode = "";
            players = [];
            showMainMenu();
        }
        
        function showProfile() {
            document.getElementById('playerNameInput').value = playerName;
            document.getElementById('profileModal').style.display = 'flex';
        }
        
        function saveProfile() {
            playerName = document.getElementById('playerNameInput').value.trim() || "Jugador";
            const currentName = players.find(p => p.name === "T√∫");
            if (currentName) {
                currentName.name = playerName;
            } else {
                players[0] = { name: playerName }; // Asegura que el primer jugador sea siempre el local
            }
            updateLobbyUI();
            document.getElementById('profileModal').style.display = 'none';
        }
        
        function showCredits() {
            document.getElementById('creditsModal').style.display = 'flex';
        }
        
        function closeCredits() {
            document.getElementById('creditsModal').style.display = 'none';
        }
    </script>
</body>
</html>
